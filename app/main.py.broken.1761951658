from fastapi import FastAPI, Query, Request, Form, Depends, Response
from fastapi.responses import JSONResponse, PlainTextResponse, RedirectResponse, HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from typing import Optional
from datetime import datetime
from app.config import load_config
from app.db import init_db, get_session, AutoCount, Controller, Season, Alert
from sqlalchemy import select, func
import os, json

# Basic auth for settings
from fastapi.security import HTTPBasic, HTTPBasicCredentials
import secrets

security = HTTPBasic()

cfg = load_config()
init_db(cfg['db_path'])

app = FastAPI(title='LightShow Visitor Tracker')

def get_current_season(now_utc):
    s = get_session()
    q = s.query(Season).order_by(Season.start_date.desc())
    for season in q.all():
        if season.start_date <= now_utc < season.end_date:
            return season
    return None

app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

def await_correlate_like(sess, season, df, dt, camera):
    from app.db import FPPStatus
    q = select(AutoCount.timestamp, AutoCount.count_value, AutoCount.camera_name).where(AutoCount.count_type=='vehicle')
    if season: q = q.where(AutoCount.season==season)
    if df: q = q.where(AutoCount.timestamp >= df)
    if dt: q = q.where(AutoCount.timestamp < dt)
    if camera: q = q.where(AutoCount.camera_name==camera)
    q = q.order_by(AutoCount.timestamp.asc())
    rows = sess.execute(q).all()
    q2 = select(FPPStatus.timestamp, FPPStatus.media).order_by(FPPStatus.timestamp.asc())
    frows = sess.execute(q2).all()
    res = {}
    j=0
    for ts, cnt, camname in rows:
        while j+1 < len(frows) and frows[j+1][0] <= ts: j+=1
        media = frows[j][1] if frows else '(unknown)'
        if not media: media='(unknown)'
        res[media] = res.get(media,0) + int(cnt)
    return sorted(res.items(), key=lambda x:x[1], reverse=True)


ADMIN_USER = os.getenv("ADMIN_USERNAME", "admin")
ADMIN_PASS = os.getenv("ADMIN_PASSWORD", "changeme")

from fastapi import HTTPException  # make sure this import exists

def require_basic(request: Request):
    # Basic auth header parse
    auth = request.headers.get("Authorization", "")
    if not auth.startswith("Basic "):
        # Tell the browser to prompt for creds
        raise HTTPException(
            status_code=401,
            detail="Unauthorized",
            headers={"WWW-Authenticate": 'Basic realm="GlowSync"'}
        )

    import base64, os
    try:
        userpass = base64.b64decode(auth.split(" ", 1)[1]).decode("utf-8")
        username, password = userpass.split(":", 1)
    except Exception:
        raise HTTPException(
            status_code=401,
            detail="Bad auth header",
            headers={"WWW-Authenticate": 'Basic realm="GlowSync"'}
        )

    expected_user = os.getenv("ADMIN_USERNAME", "admin")
    expected_pass = os.getenv("ADMIN_PASSWORD", "changeme")
    if username != expected_user or password != expected_pass:
        raise HTTPException(
            status_code=401,
            detail="Invalid credentials",
            headers={"WWW-Authenticate": 'Basic realm="GlowSync"'}
        )

    # returning True satisfies FastAPI's Depends()
    return True
@app.get('/')
def root():
    return RedirectResponse('/dashboard')

@app.get('/health')
def health():
    return {'ok': True}

def _parse_time(s):
    if not s: return None
    try:
        return datetime.fromisoformat(s)
    except Exception:
        try:
            return datetime.fromisoformat(s + 'T00:00:00')
        except Exception:
            return None

@app.get('/counts')
def counts(type: str, 
           date_from: Optional[str] = Query(None),
           date_to: Optional[str] = Query(None)):
    df = _parse_time(date_from)
    dt = _parse_time(date_to)
    s = get_session()
    q = select(func.strftime('%Y-%m-%d %H:%M', AutoCount.timestamp).label('minute'),
               func.sum(AutoCount.count_value)).where(AutoCount.count_type==type)
    if df: q = q.where(AutoCount.timestamp >= df)
    if dt: q = q.where(AutoCount.timestamp < dt)
    q = q.group_by('minute').order_by('minute')
    rows = s.execute(q).all()
    return {'type': type, 'series': [{'minute': r[0], 'count': int(r[1])} for r in rows]}

@app.get('/dashboard', response_class=HTMLResponse)
def dashboard(
    request: Request,
    group: str = 'hour',
    season: str = '',
    camera: str = '',
    date_from: Optional[str] = Query(None, alias='from'),
    date_to: Optional[str]   = Query(None, alias='to'),
    corr: str = 'media'
):
    import os, json, pytz
    from datetime import datetime, timedelta, timezone
    from sqlalchemy import select, func

    tzname = os.getenv('TIMEZONE','America/Chicago')
    tz = pytz.timezone(tzname)

    def _parse_time(s):
        if not s: return None
        try: return datetime.fromisoformat(s).astimezone(timezone.utc)
        except Exception: return None

    df = _parse_time(date_from)
    dt = _parse_time(date_to)
    if not df or not dt:
        now_local = datetime.now(tz)
        dt_local = now_local
        df_local = now_local - timedelta(hours=24)
        df, dt = df_local.astimezone(timezone.utc), dt_local.astimezone(timezone.utc)

    s = get_session()
    mode = os.getenv('BALDRICK_BASELINE_MODE','manual').lower()
    baseline = int(os.getenv('BALDRICK_BASELINE','0') or 0)
    if mode == 'auto':
        try:
            rows = s.execute(
                select(AutoCount.count_value)
                .where(AutoCount.count_type=='device_seen',
                       AutoCount.source=='baldrick',
                       AutoCount.timestamp >= (datetime.now(timezone.utc)-timedelta(days=7)))
                .order_by(AutoCount.count_value.asc())
            ).scalars().all()
            if rows:
                idx = max(0, int(len(rows)*0.10)-1)
                baseline = int(rows[idx])
        except Exception:
            pass

    def series_for(ctype: str):
        q = select(AutoCount.timestamp, AutoCount.count_value, AutoCount.camera_name)            .where(AutoCount.count_type == ctype,
                   AutoCount.timestamp >= df,
                   AutoCount.timestamp <  dt)
        if season: q = q.where(AutoCount.season == season)
        if camera and ctype == 'vehicle': q = q.where(AutoCount.camera_name == camera)
        q = q.order_by(AutoCount.timestamp.asc())

        rows = s.execute(q).all()
        buckets = {}
        for ts_utc, val, cam in rows:
            ts_local = ts_utc.astimezone(tz)
            label = ts_local.strftime('%Y-%m-%d %H:%M') if group=='min' else (
                ts_local.strftime('%Y-%m-%d') if group=='day'
                else ts_local.strftime('%Y-%m-%d %H:00')
            )
            if ctype == 'device_seen':
                v = max(int(val) - baseline, 0)
                agg = buckets.get(label, {'sum':0,'n':0})
                agg['sum'] += v; agg['n'] += 1; buckets[label]=agg
            else:
                buckets[label] = buckets.get(label,0)+int(val)
        labels = sorted(buckets.keys())
        values = [int(round(buckets[k]['sum']/max(buckets[k]['n'],1))) if isinstance(buckets[k],dict) else buckets[k] for k in labels]
        total = sum(values) if values else 0
        peak_label, peak_count = ('â€”', 0)
        if values:
            idx = max(range(len(values)), key=lambda i: values[i])
            peak_label, peak_count = labels[idx], values[idx]
        return {'labels': labels, 'values': values, 'total': total, 'peak': {'label': peak_label, 'count': peak_count}}

    veh, dev = series_for('vehicle'), series_for('device_seen')
    total = s.query(Controller).count()
    online = s.query(Controller).filter(Controller.last_status=='online').count()
    fpp = s.query(Controller).filter(Controller.kind=='fpp').order_by(Controller.id.asc()).first()
    fpp_info = {}
    if fpp and fpp.last_info_json:
        try: fpp_info=json.loads(fpp.last_info_json)
        except: fpp_info={}

    seasons_list = s.query(Season).order_by(Season.start_date.desc()).all()
    cameras = [r[0] for r in s.execute(select(AutoCount.camera_name).where(AutoCount.camera_name != None).group_by(AutoCount.camera_name)).all()]
    alerts = s.execute(select(Alert.timestamp, Alert.message).where(Alert.active==1).order_by(Alert.timestamp.desc()).limit(5)).all()

    return templates.TemplateResponse('dashboard.html',{
        'request': request, 'title':'Dashboard',
        'charts': {'vehicle':veh,'device_seen':dev},
        'totals': {'vehicle':veh['total'],'device_seen':dev['total']},
        'peaks': {'vehicle':veh['peak'],'device_seen':dev['peak']},
        'controllers': {'online':online,'total':total},
        'fpp': fpp_info, 'seasons':seasons_list,'cameras':cameras,'alerts':alerts,
        'params': {'from':date_from or '','to':date_to or '','group':group,
                   'season':season,'camera':camera,'corr':corr,
                   'baseline':baseline,'baseline_mode':mode}
    })
:
    # Localize start/end (midnight local) then convert to UTC
    tzname = os.getenv('TIMEZONE', 'America/Chicago')
    tz = pytz.timezone(tzname)

    try:
        s_local = tz.localize(datetime.strptime(start.strip(), '%Y-%m-%d'))
        e_local = tz.localize(datetime.strptime(end.strip(), '%Y-%m-%d'))
    except Exception:
        # Fallback: simple parse + assume local tz
        s_local = tz.localize(datetime.fromisoformat(start.strip()))
        e_local = tz.localize(datetime.fromisoformat(end.strip()))

    s_utc = s_local.astimezone(pytz.UTC)
    e_utc = e_local.astimezone(pytz.UTC)

    s = get_session()
    season = Season(
        name=name.strip(),
        start_date=s_utc,
        end_date=e_utc,
        show_start=show_start.strip(),
        show_end=show_end.strip(),
        bucket_minutes=int(bucket or 1)
    )
    s.add(season)
    s.commit()
    return RedirectResponse('/seasons', status_code=303)

@app.get('/seasons/delete/{sid}')
def seasons_delete(sid: int, auth: bool = Depends(require_basic)):
    s = get_session()
    z = s.get(Season, sid)
    if z:
        s.delete(z); s.commit()
    return RedirectResponse('/seasons', status_code=303)

@app.get('/storage', response_class=HTMLResponse)
def storage_page(request: Request, auth: bool = Depends(require_basic)):
    s = get_session()
    seasons = s.query(Season).order_by(Season.start_date.desc()).all()
    dbp = os.getenv('DB_PATH','data/tracker.db')
    try:
        size_mb = round(os.path.getsize(dbp)/1048576, 2)
    except FileNotFoundError:
        size_mb = 0.0
    return templates.TemplateResponse('storage.html', {'request': request, 'seasons': seasons, 'db': {'path': dbp, 'size_mb': size_mb}})

@app.post('/purge')
def purge(before: str = Form(''), season_name: str = Form(''), auth: bool = Depends(require_basic)):
    s = get_session()
    from dateutil.parser import isoparse
    q = s.query(AutoCount)
    if season_name:
        q = q.filter(AutoCount.season==season_name)
    elif before:
        try:
            dt = isoparse(before + 'T00:00:00')
            q = q.filter(AutoCount.timestamp < dt)
        except Exception:
            return JSONResponse({'error':'bad date'}, status_code=400)
    else:
        return JSONResponse({'error':'no criteria'}, status_code=400)
    deleted = 0
    for row in q.all():
        s.delete(row); deleted += 1
    s.commit()
    # VACUUM
    s.execute('VACUUM')
    return RedirectResponse('/storage', status_code=303)

@app.get('/export.xlsx')
def export_xlsx(season: str, group: str = 'day', auth: bool = Depends(require_basic)):
    s = get_session()
    buf = BytesIO()
    wb = xlsxwriter.Workbook(buf, {'in_memory': True})
    ws = wb.add_worksheet('Summary')
    fmt_h = wb.add_format({'bold': True})
    ws.write_row(0,0, ['Season','GroupBy','Generated'], fmt_h)
    from datetime import datetime as _dt
    ws.write_row(1,0,[season, group, _dt.utcnow().isoformat()+'Z'])
    # Vehicles/devices sheets
    def write_sheet(ctype, name):
        ws2 = wb.add_worksheet(name)
        fmt = '%Y-%m-%d' if group=='day' else '%Y-%m-%d %H:00'
        q = select(func.strftime(fmt, AutoCount.timestamp).label('bucket'),
                   func.sum(AutoCount.count_value)).where(AutoCount.count_type==ctype, AutoCount.season==season).group_by('bucket').order_by('bucket')
        rows = s.execute(q).all()
        ws2.write_row(0,0,['bucket','count'], fmt_h)
        for i,(b,v) in enumerate(rows, start=1):
            ws2.write(i,0,b); ws2.write(i,1,int(v))
    write_sheet('vehicle','Vehicles')
    write_sheet('device_seen','Devices')
    wb.close()
    buf.seek(0)
    return Response(buf.read(), media_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                    headers={'Content-Disposition': f'attachment; filename="{season.replace(" ","_")}_export.xlsx"'})

@app.get('/correlate')
def correlate(group: str = 'media', season: str = '', date_from: Optional[str] = None, date_to: Optional[str] = None):
    # For each AutoCount bucket (vehicles), attach last-known FPPStatus at/before that timestamp, then group/sum.
    df = _parse_time(date_from)
    dt = _parse_time(date_to)
    s = get_session()
    # Build rows via Python (SQLite correlated subqueries are trickier without window functions)
    q = select(AutoCount.timestamp, AutoCount.count_value).where(AutoCount.count_type=='vehicle')
    if season:
        q = q.where(AutoCount.season==season)
    if df: q = q.where(AutoCount.timestamp >= df)
    if dt: q = q.where(AutoCount.timestamp < dt)
    q = q.order_by(AutoCount.timestamp.asc())
    rows = s.execute(q).all()
    # Preload FPP statuses
    from app.db import FPPStatus
    q2 = select(FPPStatus.timestamp, FPPStatus.playlist, FPPStatus.media).order_by(FPPStatus.timestamp.asc())
    frows = s.execute(q2).all()
    # Walk with pointer
    res = {}
    j = 0
    for ts, cnt in rows:
        while j+1 < len(frows) and frows[j+1][0] <= ts:
            j += 1
        label = None
        if frows:
            label = frows[j][1] if group=='playlist' else frows[j][2]
        if not label: label = '(unknown)'
        res[label] = res.get(label, 0) + int(cnt)
    # Return as sorted list
    ranked = sorted(([k,v] for k,v in res.items()), key=lambda x: x[1], reverse=True)
    return {'group': group, 'season': season, 'series': [{'label': k, 'count': v} for k,v in ranked]}
